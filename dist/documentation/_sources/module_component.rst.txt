Module: Component
=================

.. highlight:: js
   :linenothreshold: 5

Overview
--------

This module provides a GUI Component programming model for web application. It is inspired by Facebook's
React (https://facebook.github.io/react/) and uses a Virtual DOM implementation for its rendering engine. While it
follows the general ideas of React, it does some things very differently.

A Component represents a GUI element. It is conceived of a current state and its visual representation.
Let's assume a GUI element for a navigation menu. The navigation menu contains some menu items which
direct the user to different parts of the web application. Additionally it contains a "Change language"
dropdown that let's the user choose a translation for the web application. If the user switches to another language,
the navigation menu itself shows in the new language according to the entire web application.

In this example, the current state of the navigation menu consists of at least all the menu items and the currently selected
language to highlight in the language dropdown. Furthermore, the current translation of the
navigation menu is also part of its current state.

Thus, the current state of the navigation menu component is represented by:

* the menu items
* the currently selected language
* all available languages

In Javascript the current state could be collected in a simple object like this::

    var state = {
        language: {
            selected: 'en',
            available: ['de','en']
        },
        menu: {
            about: 'http://...',
            contact: 'http://...',
            register: 'http://...',
            login: 'http://...'
        },
        translation: {
            about: 'About',
            contact: 'Contact',
            register: 'Sign up',
            login: 'Login'
        }
    };

The visual representation of this state could be something like this:

.. code-block:: html

	<div class="main-navigation">
		<ul class="menu">
			<li><a href="#!">About</a></li>
			<li><a href="#!">Contact</a></li>
			<li><a href="#!">Sign up</a></li>
			<li><a href="#!">Login</a></li>
		</ul>
		<ul class="language">
			<li class="active"><a href="#!">English</a></li>
			<li lang="de"><a href="#!">Deutsch</a></li>
		</ul>
	</div>

In mathematical terms the visual representation is a function of the state:

    F(state) = HTML

If the current state changes, its visual representation changes accordingly. Let's say the
user selects another language. This should change the state to:

.. code-block:: js
	:linenos:
	:emphasize-lines: 3,13-16

	var state = {
		language: {
			selected: 'de',
			available: ['de','en']
		},
		menu: {
			about: 'http://...',
			contact: 'http://...',
			register: 'http://...',
			login: 'http://...'}
		},
		translation: {
			about: 'Über uns',
			contact: 'Kontakt',
			register: 'Registrieren',
			login: 'Login'
		}
	};

The new state renders to a new visual representation:

.. code-block:: html
	:linenos:
	:emphasize-lines: 3-6,10

	<div class="main-navigation">
		<ul class="menu">
			<li><a href="#!">Über uns</a></li>
			<li><a href="#!">Kontakt</a></li>
			<li><a href="#!">Registrieren</a></li>
			<li><a href="#!">Login</a></li>
		</ul>
		<ul class="language">
			<li><a href="#!">English</a></li>
			<li lang="de" class="active"><a href="#!">Deutsch</a></li>
		</ul>
	</div>

Because state changes automatically lead to a change of their visual representation, the visual
representation is never altered directly by e.g. manipulating the DOM tree. Instead state changes are
triggered through a well-defined set of **state transitions** and the automated process of
transforming the state to its visual representation is triggered whenever a state transition occurs.

In practical terms, the Component exposes a render function which receives the current state and creates a
HTML representation. This representation is compared to the current state of the DOM tree which is altered
to match the new representation.

.. code-block:: none

    current state -> render() -> new HTML -> diff'ed to DOM -> patch the DOM


Dependencies
------------

This module uses the following libraries and modules:

=============== =================================================== ==================
Module          Repository                                          AMD module alias
=============== =================================================== ==================
morphdom        https://github.com/patrick-steele-idem/morphdom     morphdom
superagent      https://github.com/visionmedia/superagent           superagent
jQuery          https://jquery.com                                  $
underscore      http://underscorejs.org/                            _
=============== =================================================== ==================

All dependencies are provided in the ``dist`` directory at https://github.com/datenwelt/cargo-js.git. Additionally
an implementation of the Promise/A+ specification is needed (which is provided by all modern browsers).


Code example
------------

As a practical example, the navigation menu component from above is built from scratch with
requirejs for dependency management. Let's start with an empty HTML page and a placeholder
for the nav menu. This is pretty much requirejs boilerplate.

Project structure
^^^^^^^^^^^^^^^^^

The overall project structure is:

.. code-block:: none

    index.html
        js/app.js

        js/lib/component.js

        js/lib/third-party/jquery.js
        js/lib/third-party/morphdom.js
        js/lib/third-party/requirejs.js
        js/lib/third-party/superagent.js
        js/lib/third-party/handlebars.js
        js/lib/third-party/underscore.js

        html/nav.html

The file ``index.html`` is the web page which loads ``app.js`` via requirejs. The files in
``js/lib`` come from the cargo repository, everything under ``js/lib/third-party`` comes
from third party vendors.

The file ``html/nav.html`` is an empty HTML-file for now and will carry the HTML template of
the navigation menu later.

We do not use any CSS or other styling for clarity. You can add it later if you want.

Setting up the boilerplate
^^^^^^^^^^^^^^^^^^^^^^^^^^

Within ``index.html`` we define an element which later receives the rendered navigation menu. Note that
we load jQuery as a global and not by requirejs. Technically, this is not necessary but as most HTML frameworks require
jQuery it is needed as a global anyways.

``index.html``

.. code-block:: html

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Component.js - example project</title>
    </head>
    <body>

    <nav id="nav" />

    <script type="text/javascript" src="js/lib/third-party/jquery.js"></script>
    <script type="text/javascript" data-main="js/app.js" src="js/lib/third-party/require.js"></script>

    </body>
    </html>

In ``js/app.js`` we load all required dependencies and provide a starting point.

``js/app.js``

.. code-block:: js
	:linenos:

	require.config({
		paths: {
			'cargo.Component': 'lib/component',
			'morphdom': 'lib/third-party/morphdom',
			'Handlebars': 'lib/third-party/handlebars',
			'superagent': 'lib/third-party/superagent'
			'underscore: 'lib/third-party/underscore
		}
	});

	require(['cargo.Component'], function(Component) {

	});

Next we define a global object ``TRANSLATIONS`` containing the English and German translations to
have them at hand when needed.

``js/app.js``

.. code-block:: js
	:linenos:
	:lineno-start: 11

	require(['cargo.Component'], function(Component) {

		var TRANSLATIONS = {
			'de': {
				about: 'Über uns',
				contact: 'Kontakt',
				register: 'Registrieren',
				login: 'Login'
			},
			'en': {
				about: 'About',
				contact: 'Contact',
				register: 'Sign up',
				login: 'Login'
			}
		}

	});

Defining and attaching a component
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's define the navigation menu component and attach it to the ``<nav>`` element in the web page. The
``cargo.Component`` module provides a builder to achieve this. Additionally we need a first action,
that constitutes the initial state of the component.

``js/app.js``

.. code-block:: js
    :linenos:
	:lineno-start: 28

	/* ... */

	var state = {
		language: {
			selected: 'en',
			available: ['de', 'en']
		},
		menu: {
			about: '#about',
			contact: '#contact',
			register: '#register',
			login: '#login'
		},
		translation: TRANSLATIONS['en']
	};

	var component = new Component();
	var renderer = component.attach('#id');
	renderer.render(state);

In line 50-51 we attach the component to the ``<nav id="nav">`` element. Attaching the component to the DOM
marks the selected nodes - in this case the ``<nav> `` element - as rendering targets for a renderer which is
returned by the ``attach()`` method. This renderer has a method ``render()`` which receives the current state and
renders its HTML representation to the DOM.

If we run this example, we should see the current state as a JSON representation at the place where the placeholder
``<nav>`` element was. That is the default behaviour of a component when it is not tied to a template yet.

Visualizing state changes
^^^^^^^^^^^^^^^^^^^^^^^^^

But let's try something else before we connect the component to a template. We change the state and watch the GUI
update the ``<nav`` element accordingly. We can attach another rendering operation with a different state inside a timer.

``js/app.js``

.. code-block:: js
	:linenos:
	:lineno-start: 46

	/* ... */

	window.setInterval(function() {
		state.language.selected = state.language.selected === 'en' ? 'de' : 'en';
		state.translation = TRANSLATIONS[state.language.selected];
		renderer.render(state);
	}, 3000);

If we run this example, the component should change the language from English to German back and forth every
3 seconds. A timer changes the state within the callback and calls the ``render()`` with the new state. Accordingly the
visual representation changes as well. Note that, this happens without any direct DOM manipulation.

Adding an HTML template
^^^^^^^^^^^^^^^^^^^^^^^

Let's connect an HTML template to have a real visual representation for the navigation menu. First we define
the template in a separate HTML file and load this file.

``html/nav.html``

.. code-block:: html
    :linenos:

	<!DOCTYPE html>
	<html>
	<body>
	<template>
		<div class="main-navigation">
			<ul class="menu">
				<li><a href="{{menu.about}}">{{translation.about}}</a></li>
				<li><a href="{{menu.contact}}">{{translation.contact}}</a></li>
				<li><a href="{{menu.register}}">{{translation.register}}</a></li>
				<li><a href="{{menu.login}}">{{translation.login}}</a></li>
			</ul>
			<ul class="language">
				<li><a href="#!" lang="en">English</a></li>
				<li><a href="#!" lang="de">Deutsch</a></li>
			</ul>
		</div>
	</template>
	</body>
	</html>

Component.js uses the Handlebars template engine (s. http://handlebarsjs.com) and applies the current
state as context to the template. In short, there are placeholders which are enclosed in moustache like
braces which correspond to the properties of the state object. For instance, the state object holds
a property ``menu`` which is an object itself. The ``menu`` object contains the properties ``about``, ``contact``
etc. which hold the link targets for the menu item. In the template these link targets are referenced
by the placeholders ``{{menu.about}}``  and ``{{menu.contact}}``.

Let's load the template into a variable and pass it to the builder. This connects the template
to the component. In the following code block we show the complete file ``js/app.js`` omitting some
details for brevity and a better overview.

Additionally we add a method to the renderer which changes the language.

``js/app.js``

.. code-block:: js
    :linenos:

	require.config({
		paths: {
			/* ... */
		}
	});

	require(['cargo.Component'], function (Component) {

		/* ... */

		Component.load("html/nav.html").then(function(comp) {

			var state = { /* ... */ };
			var renderer = comp.attach('#nav');

			renderer.changeLanguage = function(lang) {
				state.language.selected = lang;
				state.translation = TRANSLATIONS[lang];
				return renderer.render(state);
			};

			window.setInterval(function() {
				var lang = state.language.selected === 'en' ? 'de' : 'en';
				renderer.changeLanguage(lang);
			}, 3000);
		});

	});

Component.js has a static function ``load()`` which receives an URL as argument. The function
loads and compiles the file from the URL. Because loading the file is an asynchronous operation,
the function returns a Promise which is fulfilled with the component instance connected to the template.

If we run the code so far, a (rather unstyled) HTML representation of the navigation menu should
be displayed in the web page. It consists of two unnumbered lists - one for the menu itself and
another for the language options. The language should change every 3 seconds from English to German
back and forth all over again.

Adding interactivity
^^^^^^^^^^^^^^^^^^^^

To add some interactivity, lets remove the timer and add a click handler to the language menu instead.
We could add the click handler in ``js/app.js`` as soon as the component has rendered but there are
two problems with this approach. First, we have no way to determine when the HTML finishes rendering and
cannot register the event handler before the respective elements have been attached to the DOM.

The second problem may be even more important. Adding event handlers outside of the template, loses us
some flexibility. The event handler has to be attached to some specific element defined in the template.
If we reference this element **outside** of the template, we cannot change the HTML without
at least paying attention to the Javascript code and checking back the references between both files.

The cleaner approach would be not to reference the component's DOM within its Javascript code at all.
That's why we provide a way to define event handlers and DOM related stuff **in the HTML template**. Let's
see it in our example template:

``html/nav.html``

.. code-block:: html
	:linenos:
	:emphasize-lines: 18-24

	<!DOCTYPE html>
		<html>
		<body>
		<template>
			<div class="main-navigation">
				<ul class="menu">
					<li><a href="{{menu.about}}">{{translation.about}}</a></li>
					<li><a href="{{menu.contact}}">{{translation.contact}}</a></li>
					<li><a href="{{menu.register}}">{{translation.register}}</a></li>
					<li><a href="{{menu.login}}">{{translation.login}}</a></li>
				</ul>
				<ul class="language">
					<li><a href="#!" lang="en">English</a></li>
					<li><a href="#!" lang="de">Deutsch</a></li>
				</ul>
			</div>
		</template>
		<script class="attach">
			var renderer = this;
			$(node).find("ul.language li a[lang]").on('click', function() {
				var lang = $(this).attr('lang');
				renderer.changeLanguage(lang);
			});
		</script>
		</body>
		</html>

There is a ``script`` tag in the body of the template with the class ``attach``. This script
is executed **once** when the component is attached to the DOM. It is the right place to
setup event handlers and other DOM related things that need to be executed before the
component is used. There are two more script classes  - ``update`` and ``detach``. ``update``
is executed whenever the component is re-rendered on state changes and ``detach`` is called
once when the component is destroyed.

In the execution context of these scripts, ``this`` is defined as a reference to the renderer and
a special variable ``node`` is defined as a reference to the DOM node of the component. You
can use ``this`` to access all methods of the renderer and trigger some interactive behaviour.

Conclusion
^^^^^^^^^^

By separating the component's behaviour from its visual appearance and by accessing the
behaviour through **state transitions** as a well-defined interface, we think that we provided a
solution for writing large GUI applications in a more comprehensive and more concise manner.

We use modern concept's from the Javascript world like Promises, Flux and React-style
application architecture to provide a clear data flow between the applications model
and it's visual representation and try to avoid the syntactical overhead of JSX.

Our approach is very close to the up-coming "Web components" technology and may easily be
transformed into a programming model making use of them.

Please feel free to check the API documentation for a more in-depth look at our technology.

API
---



